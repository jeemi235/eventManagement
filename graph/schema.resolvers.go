package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.29

import (
	dataloader "10/dataloaders"
	database "10/db"
	"10/graph/model"
	"context"
	"fmt"
	"log"
	"strconv"
	"time"
)

// CreateUser is the resolver for the creating a new user.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	//we have created new variable to get input
	var newuser model.NewUser

	newuser = model.NewUser{
		Name:  input.Name,
		Phone: input.Phone,
	}

	//we are connecting our database
	db := database.Connect()
	if _, err := db.Exec(
		"Insert into users(name,phone) values($1,$2)", newuser.Name, newuser.Phone); err != nil {
		log.Println(err)
	} else {
		log.Println("User registered succesfully")
	}

	return &model.User{}, nil
}

// CreateEvent is the resolver for creating new event
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.NewEvent) (*model.Event, error) {
	var newevent model.NewEvent

	newevent = model.NewEvent{
		Name:        input.Name,
		Date:        input.Date,
		Duration:    input.Duration,
		Location:    input.Location,
		Category:    input.Category,
		Description: input.Description,
		Price:       input.Price,
		Hosted_by:   input.Hosted_by,
	}

	db := database.Connect()
	if _, err := db.Exec(
		`insert into events(name,date,duration,location,category,
			description,price,hosted_by) values($1,$2,$3,$4,$5,$6,$7,$8)`,
		newevent.Name, newevent.Date, newevent.Duration, newevent.Location, newevent.Category, newevent.Description, newevent.Price, newevent.Hosted_by); err != nil {
		log.Println(err)
	} else {
		log.Println("Event created succesfully")
	}

	return &model.Event{}, nil
}

// UpdateEvent is the resolver for updating an event
func (r *mutationResolver) UpdateEvent(ctx context.Context, input model.UpdateEvent) (*model.Event, error) {
	var event model.UpdateEvent

	event = model.UpdateEvent{
		ID:          input.ID,
		Name:        input.Name,
		Date:        input.Date,
		Duration:    input.Duration,
		Location:    input.Location,
		Category:    input.Category,
		Description: input.Description,
		Price:       input.Price,
	}

	db := database.Connect()
	if _, err := db.Exec(
		"UPDATE events set price=$1 where id=5;", event.Price); err != nil {
		log.Println(err)
	}

	log.Println("event updated succesfully")
	return &model.Event{}, nil
}

// DeleteEvent is the resolver for deleting an event
func (r *mutationResolver) DeleteEvent(ctx context.Context, id string) (string, error) {
	db := database.Connect()
	rows, err := db.Query("delete from events where id=$1", id)
	if err != nil {
		log.Println(err)
	}
	defer rows.Close()

	log.Println("event deleted succesfully")
	return id, nil
}

// Bookevent is the resolver for booking an event for user
func (r *mutationResolver) Bookevent(ctx context.Context, input model.NewEventUser) (*model.EventUser, error) {
	var event model.EventUser

	event = model.EventUser{
		Event_id: input.Event_id,
		User_id:  input.User_id,
	}

	db := database.Connect()
	if _, err := db.Exec(
		`insert into events_user(event_id,user_id) values($1,$2)`, event.Event_id, event.User_id); err != nil {
		log.Println(err)
	} else {
		log.Println("Booked event succesfully")
	}

	return &model.EventUser{}, nil
}

// User is the resolver for showing list of all the users
func (r *queryResolver) User(ctx context.Context) ([]*model.User, error) {
	start := time.Now()
	db := database.Connect()
	rows, err := db.Query("select * from users where id in (1,2)")
	if err != nil {
		log.Println(err)
	}
	defer rows.Close()

	r.users = nil

	for rows.Next() {
		var user model.User
		if err := rows.Scan(&user.ID, &user.Name, &user.Phone); err != nil {
			log.Println(err)
		}
		r.users = append(r.users, &user)
	}
	if err := rows.Err(); err != nil {
		log.Println(err)
	}

	log.Println("Showing list of users")
	fmt.Println("timing.....", time.Since(start))
	return r.users, nil
}

// Event is the resolver for showing the list of all the events
func (r *queryResolver) Event(ctx context.Context) ([]*model.Event, error) {
	//will connect the database
	db := database.Connect()
	rows, err := db.Query("select * from events")
	if err != nil {
		log.Println(err)
	}
	defer rows.Close()

	r.events = nil

	//Traverse for every rows and put that into event variable
	for rows.Next() {
		var event model.Event
		if err := rows.Scan(&event.ID, &event.Name, &event.Date, &event.Duration, &event.Location, &event.Category, &event.Description, &event.Price, &event.Hosted_by); err != nil {
			log.Println(err)
		}
		r.events = append(r.events, &event)
	}
	if err := rows.Err(); err != nil {
		log.Println(err)
	}

	log.Println("Showing list of Events")
	return r.events, nil
}

// EventUser is the resolver for showing list of all the users who have booked the event
func (r *queryResolver) EventUser(ctx context.Context, id string) ([]*model.EventUser, error) {
	//converting id from string to int
	x, _ := strconv.Atoi(id)

	db := database.Connect()
	rows, err := db.Query("select * from events_user where event_id=$1", x)
	if err != nil {
		log.Println(err)
	}
	defer rows.Close()

	r.eventusers = nil

	for rows.Next() {
		var eventuser model.EventUser
		if err := rows.Scan(&eventuser.ID, &eventuser.Event_id, &eventuser.User_id); err != nil {
			log.Println(err)
		}
		r.eventusers = append(r.eventusers, &eventuser)
	}
	if err := rows.Err(); err != nil {
		log.Println(err)
	}

	log.Println("Showing list of users who booked event ")
	return r.eventusers, nil
}

// EventHostby is the resolver for the Event_Hostby field.
func (r *queryResolver) EventHostby(ctx context.Context, id string) ([]*model.Event, error) {
	//converting id from string to int
	x, _ := strconv.Atoi(id)

	db := database.Connect()
	rows, err := db.Query("select * from events where hosted_by=$1", x)
	if err != nil {
		log.Println(err)
	}
	defer rows.Close()

	r.events = nil

	for rows.Next() {
		var event model.Event
		if err := rows.Scan(&event.ID, &event.Name, &event.Date, &event.Duration, &event.Location, &event.Category, &event.Description, &event.Price, &event.Hosted_by); err != nil {
			log.Println(err)
		}
		r.events = append(r.events, &event)
	}
	if err := rows.Err(); err != nil {
		log.Println(err)
	}

	log.Println("Showing list of Events")
	return r.events, nil
}

// PastEvents is the resolver for the Past_Events field.
func (r *queryResolver) PastEvents(ctx context.Context) ([]*model.Event, error) {
	db := database.Connect()

	current := time.Now()
	current.Format("2006-01-02")
	rows, err := db.Query("select * from events where date<$1", current)
	if err != nil {
		log.Println(err)
	}
	defer rows.Close()

	r.events = nil

	for rows.Next() {
		var event model.Event
		if err := rows.Scan(&event.ID, &event.Name, &event.Date, &event.Duration, &event.Location, &event.Category, &event.Description, &event.Price, &event.Hosted_by); err != nil {
			log.Println(err)
		}
		r.events = append(r.events, &event)
	}
	if err := rows.Err(); err != nil {
		log.Println(err)
	}

	log.Println("Showing list of Events")
	return r.events, nil
}

// EventByCategory is the resolver for the eventByCategory field.
func (r *queryResolver) EventByCategory(ctx context.Context, category string) ([]*model.Event, error) {
	db := database.Connect()

	rows, err := db.Query("select * from events where category=$1", category)
	if err != nil {
		log.Println(err)
	}
	defer rows.Close()

	r.events = nil

	for rows.Next() {
		var event model.Event
		if err := rows.Scan(&event.ID, &event.Name, &event.Date, &event.Duration, &event.Location, &event.Category, &event.Description, &event.Price, &event.Hosted_by); err != nil {
			log.Println(err)
		}
		r.events = append(r.events, &event)
	}
	if err := rows.Err(); err != nil {
		log.Println(err)
	}

	log.Println("Showing list of Events")
	return r.events, nil
}

// EventByLocation is the resolver for the eventByLocation field.
func (r *queryResolver) EventByLocation(ctx context.Context, location string) ([]*model.Event, error) {
	db := database.Connect()

	rows, err := db.Query("select * from events where location=$1", location)
	if err != nil {
		log.Println(err)
	}
	defer rows.Close()

	r.events = nil

	for rows.Next() {
		var event model.Event
		if err := rows.Scan(&event.ID, &event.Name, &event.Date, &event.Duration, &event.Location, &event.Category, &event.Description, &event.Price, &event.Hosted_by); err != nil {
			log.Println(err)
		}
		r.events = append(r.events, &event)
	}
	if err := rows.Err(); err != nil {
		log.Println(err)
	}

	log.Println("Showing list of Events")
	return r.events, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, id string) (*model.User, error) {
	users, err := dataloader.CtxLoaders(ctx).Users.Load(id)
	if err != nil {
		log.Println(err)
	}
	return users, nil
}

// UsersByIDs is the resolver for the usersByIDs field.
func (r *queryResolver) UsersByIDs(ctx context.Context, ids []string) ([]*model.User, error) {
	start := time.Now()
	users, err := dataloader.CtxLoaders(ctx).Users.LoadAll(ids)
	if err != nil {
		log.Println(err)
	}
	fmt.Println("timing1......", time.Since(start))
	return users, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
